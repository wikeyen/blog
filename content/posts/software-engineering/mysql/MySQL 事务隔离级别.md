---
title: "MySQL 事务隔离级别"
categories:
 - software-engineering
tags:
 - mysql
 - mandarin
date: 2022-04-23T11:11:31+08:00
author: Mike. Y
draft: false

---

## 四种隔离级别

1. 读未提交：(Read Uncommitted)
2. 读已提交（Read Committed） 大多数数据库默认的隔离级别
3. 可重复读（Repeatable-Read) mysql 数据库所默认的级别
4. 序列化（serializable）



## 四种隔离级别的具体实现与不同：

### 问题

首先程序是可以并发执行的，同样，在 MySQL 中，一个表可以由两个或多个进程同时来读写数据。


比如，此时有两个进程来读数据，这也没什么问题，允许。但是如果一个进程在读某一行的数据的过程中，另一个在进程又往这一行里面写数据（改、删），那结果会是如何？同样，如果两个进程都同时对某一行数据进行更改，以谁的更改为准？那结果又会怎样，不敢想象，是不是数据就被破坏掉了。所以此时是冲突的。

既然会冲突就要想办法解决，靠谁来解决，这时候就是靠锁机制来维护了。怎么使用锁来使他们不冲突？

### 脏读与读未提交

在事务开始的时候可以给要准备写操作的这一行数据加一个排它锁，如果是读操作，就给该行数据一个读锁。这样之后，在修改该行数据的时候，不让其他进程对该行数据有任何操作。而读该行数据的时候，其他进程不能更改，但可以读。读或写完成时，释放锁，最后 commit 提交。这时候读写就分离开了，写和写也就分离开了。

注意：此时加锁和释放锁的过程由 MySQL 数据库自身来维护，不需要我们人为干涉。MySQL 开发者给这个解决冲突的方案起了一个名字叫做：读未提交：**(Read Uncommitted)**。这也就是事务的第一个隔离性。


但是这个程度的隔离性仅仅是不够的。例如：
1. A 修改事务级别为：未提交读。并开始事务，对 user 表做一次查询
2. B 事务更新一条记录
3. 此时 B 事务还未提交，A 在事务内做一次查询，发现查询结果已经改变
4. B 进行事务回滚
5. A 再做一次查询，查询结果又变回去了

因此在一个进程的事务当中，我更改了其中的一行数据，但是我修改完之后就释放了锁，这时候另一个进程读取了该数据，此时先前的事务是还未提交的，直到我回滚了数据，另一个进程读的数据就变成了无用的或者是错误的数据。我们通常把这种数据叫做脏数据，这种情况读出来的数据叫做**脏读**。

### 不可重复度与读已提交

怎么办？依然是靠锁机制。无非是锁的位置不同而已，之前是只要操作完该数据就立马释放掉锁，现在是把释放锁的位置调整到事务提交之后，此时在事务提交前，其他进程是无法对该行数据进行读取的，包括任何操作。那么数据库为此种状态的数据库操作规则又给了一个名字叫做：**读已提交（Read Committed）**，或者也可以叫**不可重复读**。这也就是事务的第二个隔离性。


在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据 A 和 B 依次查询就可能不同，A 和 B 就可能打起来了……

继续看下面的场景：
1. 把隔离性调为 READ-COMMITTED（读取提交内容）设置 A 的事务隔离级别，并进入事务做一次查询
2. B 开始事务，并对记录进行修改
3. A 再对 user 表进行查询，发现记录没有受到影响
4. B 提交事务
5. A 再对 user 表查询，发现记录被修改

此时，在同一个事务中如果两次读取相同的数据时，最后的结果却不一致。这里我们把这种现象称为：**不可重复读**。因为在第一个事务读取了数据之后，此时另一个事务把该数据给修改了，这时候事务提交，那么另一个事务在第二次读取的时候，结果就不一样，一个修改前的，一个是修改后的。

既然此种隔离性是在事务提交后才释放锁，那么在该数据未提交前，另一个事务为什么也是仍然可以读取的？其实，在这里 mysql 使用了一个并发版本控制机制 **MVCC**，目的是：MySQL 为了提高系统的并发量，在事务未提交前，虽然事务内操作的数据是锁定状态，但是另一个事务仍然可以读取，**大多数数据库默认的就是这个级别的隔离性。但 MySQL 不是**。

### 幻读与可重复度

不只是在更新数据时出现这个问题，在插入数据时仍然会造成类似的这样一种现象：MySQL 虽然锁住了正在操作的数据行，但它仍然不会阻止另一个事务往表插入新行新的数据。比如：一个事务读取或更新了表里的所有行，接者又有另一个事务往该表里插入一个新行，在事务提交后。原来读取或更改过数据的事务又第二次读取了相同的数据，这时候这个事务中两次读取的结果集行数就不一样。原来更新了所有行，而现在读出来发现竟然还有一行没有更新。这就是所谓的**幻读**。

为了防止同事务中两次读取数据不一致，（包括不可重读和幻读），MySQL 依然采取的是 MVCC 并发版本控制来解决这个问题。具体是：如果事务中存在多次读取同样的数据，MySQL 第一次读的时候仍然会保持选择读最新提交事务的数据，当第一次之后，之后再读时，mysql 会取第一次读取的数据作为结果。这样就保证了同一个事务多次读取数据时数据的一致性。这时候，mysql 把这种解决方案叫做：**可重复度（Repeatable-Read）**，也就是上述所写的第三个隔离性，也是 mysql 默认的隔离级别。

注意：幻读和不可重复读（Read Committed）都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

说到这里，真的就完事了吗？到这里其实 mysql 并未完全解决数据的一致性问题。只是在读取上做了手脚，解决了传统意义上的幻读和不可重复读。
例子：
1. A 事务开启，B 事务开启。
2. B 事务往表里面插入了一条数据，但还并未提交。
3. A 事务开始查询了，并没有发现 B 事务这次插入的数据。然后此时 B 事务提交了数据。
4. 于是乎，A 事务就以为没有这条数据，就开始添加这条数据，但是却发现，发生了数据 重复冲突。

### 序列化与锁

最后这个时候，该我们的最后一种隔离级别也是最高的隔离级别：**序列化（serializable）**。
该隔离级别会自动在锁住你要操作的整个表的数据，如果另一个进程事务想要操作表里的任何数据就需要等待获得锁的进程操作完成释放锁。可避免脏读、不可重复读、幻读的发生。当然性能会下降很多，会导致很多的进程相互排队竞争锁。

后记：以上所说的四种隔离性的锁机制应用是数据库自动完成的，不需要人为干预。隔离级别的设置只对当前链接有效。对于使用 MySQL 命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效